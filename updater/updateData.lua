#!/usr/bin/env lua
-- Script to load one or more codespell dictionary files and output
-- a single merged file.

-- Requires Lua penlight.

-- Use the preprocessWikipediaContent.sh script on any text copied right
-- from the Wikipedia page before passing it to this script: it cleans it
-- and adds the necessary trailing commas.

--[[ Original Author: Ryan Pavlik <rpavlik@iastate.edu> <abiryan@ryand.net>
Copyright 2012 Iowa State University.
Distributed under the Boost Software License, Version 1.0.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
]]


require "strict"

-- Try loading luarocks just in case it's needed for dependencies
pcall(require, "luarocks.loader")

-- Requires lua penlight
-- Looks relative to this file.
local app = require "pl.app"
app.require_here "modules"

local CorrectionDatabase = require "CorrectionDatabase"
local HandleArgs = require "HandleArgs"
data = CorrectionDatabase()

outfn = "outputdict.txt"
todelete = {}
extralines = {}
inplace = false
quiet = false

options = {
	["--quiet"] = {
		short = "-q";
		doc = "Silences status output.";
		action = function()
			quiet = true
		end;
	};

	["--delete"] = {
		short = "-d";
		doc = "Deletes a misspelling from the database before writing.";
		params = {"misspelling"};
		action = function(t)
			table.insert(todelete, t.misspelling)
		end;
	};

	["--exclusions"] = {
		short = "-e";
		doc = "Specifies a file where each line is a misspelling to delete.";
		params = {"exclusionfile"};
		action = function(t)
			local f = assert(io.open(t.exclusionfile, "r"))
			for line in f:lines() do
				table.insert(todelete, line)
			end
			f:close()
		end;
	};

	["--add"] = {
		short = "-a";
		doc = "Adds a quoted misspelling line to the database before writing.";
		params = {"databaseline"};
		action = function(t)
			table.insert(extralines, t.databaseline)
		end;
	};

	["--reason"] = {
		short = "-r";
		doc = "Disable automatic replacement of a misspelling by specifying both the misspelling and a quoted reason.";
		params = {"misspelling", "reason"};
		action = function(t)
			table.insert(extralines, ("%s->,%s"):format(t.misspelling, t.reason))
		end;
	};

	["--output"] = {
		short = "-o";
		doc = "Sets the output filename (defaults to " .. outfn .. ")";
		params = {"outfile"};
		action = function(t)
			outfn = t.outfile
		end;
	};

	["--inplace"] = {
		short = "-i";
		doc = "Sets the output filename to be equal to the first input filename";
		action = function()
			inplace = true
		end;
	};
}

local usage = HandleArgs.createUsage(options, "All additional arguments will be treated as input files.")

if #arg == 0 then
	usage()
end

local files = HandleArgs.process(options)

if inplace then
	outfn = files[1]
end

local respectfulPrint = function(...)
	if not quiet then
		print(...)
	end
end


do
	local lastTypos = 0
	local lastCorrections = 0
	displayDataStatus = function()
		local typos, corrections = data:getCounts()
		respectfulPrint( ("Status: %d [%+d] incorrect spellings, %d [%+d] corrections\n"):format(
				typos,
				typos - lastTypos,
				corrections,
				corrections - lastCorrections)
		)
		lastTypos = typos
		lastCorrections = corrections
	end
end

for i, fn in ipairs(files) do
	respectfulPrint("Loading file", fn, ("(%d of %d)"):format(i, #files))
	local f = assert(io.open(fn, "r"))
	for line in f:lines() do
		data:add(line)
	end
	f:close()
	displayDataStatus()
end

if #extralines > 0 then
	respectfulPrint("Adding entries specified on command line:", #extralines)
	for _, line in ipairs(extralines) do
		data:add(line)
	end
	displayDataStatus()
end

if #todelete > 0 then
	respectfulPrint("Deleting entries specified on command line:", #todelete)
	for _, item in ipairs(todelete) do
		data:delete(item)
	end
	displayDataStatus()
end

local typos = data:getCounts()
if typos == 0 then
	print("ERROR: No incorrect spellings in the database! Skipping writing to file!\n\n")
	usage(2) -- print usage and exit with code 2
end

respectfulPrint("Writing unified database out to:", outfn)
local f = assert(io.open(outfn, "wb"))
f:write(data:serialize())
f:close()

